README:

Εντολή μεταγλώττισης: Έχοντας προσθέσει μέσα στο παραδοτέο ένα αρχείο Makefile, χρείαζεστε μόνο την εντολή make αλλιως απλα g++ -std=c++11 -c "κάθε αρχείο πηγαίου κώδικα"
 και μετα g++ -std=c++11 -o prog +"όλα τα αντικειμενικά αρχεία".
Πληροφορίες και Αιτιολογήσεις σχετικά με τις σχεδιαστικές μου επιλογές:
	H main εκτελεί ό,τι ζητείται στην εκφώνηση ωστόσο στην αρχή καλεί την συνάρτηση start η οποία αρχικοποιεί τον πίνακα idtable, που θα περιέχει όλα τα id που έχουν χρησιμοποιήθει,
προκειμένου να μην δημιουργηθεί νέο αντικείμενο με id ίδιο με κάποιο άλλο (εκτός απο την περίπτωση που φτιάχνουμε αντίγραφο κάποιου αντικειμένου), και θέτει το seed για τις rand που θα
χρησιμοποιηθούν σε κάποιες συναρτήσεις. Η κλάση Object έχει id για data member και είναι abstract με pure virtual συναρτήσεις τις clone, dstr_clone και την toString κάθως
δεν ορίζονται αντικείμενα αυτής της κλάσης και επιθυμώ οι συγκεκριμένες συναρτήσεις να εκτελεστούν σε υποκλάσεις της.Έχει και την getID που επιστρέφει το id και την setID που αλλάζει το
id. Η κλάση String είναι υλοποιημένη με string για data member και συναρτήσεις που χρησιμοποιούν τις συναρτήσεις των string πέρα απο την concat που παίρνει μια συμβολοσειρά και την
προσαρτίζει στην String καθώς και τις at,updateAt και print που εκτελούν τα ζητούμενα της εκφώνησης και την getSTR για να πάρουμε το data member της κλάσης. Όλες οι υπόλοιπες κλάσεις
έχουν υλοποιηθεί σύμφωνα με τους ορισμούς τους στην εκφώνηση και περιέχουν τα data member που χρειάζονται και τις συναρτήσεις που ζητούνται. Ως inline έχω ορίσει κυρίως συναρτήσεις με
λίγες γραμμές κώδικα που υλοποιούν απλές λειτουργίες. Όσον αφορά την κλάση PassengerCompartment επέλεξα να υλοποιήσω τον πίθανό εσωτερικό χώρο επιβατών με δείκτη PassengerCompartment
ο οποίος όταν καλείται ο constructor είτε δείχνει σε NULL όταν δεν υπάρχει εσωτερικός χώρος (το οποίο συμβαίνει πιο συχνά) αλλιώς σε PassengerCompartment για τον οποίο καλείται πάλι
ο constructor. Το αν υπάρχει ή όχι εσωτερικός χώρος επιλέγεται τυχαία με μια μια rand(). Επίσης για το CargoBay, τον εσωτερικό του χώρο εξοπλισμού τον υλοποιώ με δείκτη σε EquipmentCompartment
αφού πάντα περιέχει εσωτερικό χώρο εξοπλισμού. Όλες οι toString και ready_check συναρτήσεις θεώρω είναι απλό το τι κάνουν όμως πρέπει να αναφέρω ότι έκανα virtual τις συναρτήσεις που ανέφερα στην
προηγούμενη πρόταση στο σώμα της PrivateCompartment ώστε να αποφύγω τύχον μπέρδεμα στην περίπτωση που χω δείκτη τύπου PrivateCompartment που δείχνει σε κάποια απο τις δύο υποκλάσεις τις.
Κάθε process παίρνει σαν όρισμα αναφορά σε Employee και καλεί την workOn με όρισμα το PlaneComponent στο οποίο βάζουμε να δουλέψει ο εργαζόμενος.Οι report συναρτήσεις εκτυπώνουν
κατάλληλα μηνύματα σχετικά με την δουλεία κάθε εργαζόμενου.Οι workOn εκτυπώνει μήνυμα με το id του εργαζόμενου και μια περιγραφή του χώρου στον οποίο δουλεύει.Η Plane έχει τα data members
που ζητούνται και τα μέρη του αεροπλάνου (υλοποιημένα παρόμοια με τους εσωτερικόυς χώρους που ανέφερα παραπάνω).Ο constructor της καλεί τους constructor κάθενος από τα μέρη του αεροπλάνο καθώς
δεσμεύει δυναμικά την απαιτούμενη μνήμη για αυτά, ενώ επιλέγει το πλήθος των χώρων επιβατών τυχαία σε συνάρτηση με το capacity και το περιορίζει στο δίαστημα [2,5] το οποίο θεώρησα
εγώ λογικό για ένα αεροπλάνο (αλλιώς θα ταν κάπως φανταστικό :D). Για την περιγραφή του αεροπλάνου παίρνω τις περιγραφές των μερών του και τις προσαρτίζω στην συνολική περιγραφή
του αεροπλάνου.Ιδιαίτερη σημασία έχει ,θεωρώ, η υλοποιήση της clone.Έχω ορίσει pure virtual την clone του Object (είναι abstract) και του Employee(παρομοίως) ενώ virtual 
την clone της PrivateCompartment(πάλι για τον λόγο που ανέφερα προηγουμένως).Κάθε clone είναι αρκετά διαφορετική απο τις υπόλοιπες( εκτός απο μερικές που μοιάζουν πολύ) παρ' όλα αυτά
όλες έχουν κοινό το γεγονός ότι παίρνουν το id του αντικειμένου που αντιγράφουν με την getID και αλλάζουν με την setID το id του αντιγράφου.Στα PlaneComponent που έχουν κάποιο εσωτερικό
στοιχείο το οποίο κατα κύριο λόγο είναι δυναμικά δεσμευμένο( ή NULL αν δεν υπάρχει) διαγράφω τα μέλη του Object που φτιάχνω,αν υπάρχουν, και ανάλογα αν υπάρχουν τα αντίστοιχα μέλη του Object
που θέλω να αντιγράψω, καλώ την clone για αυτά και επιστρέφεται δείκτης με την κατάλληλη τιμή για την θέση που του αναλογεί.Αυτό γίνεται πχ στην Plane,στην CargoBay και στην PassengerCompartment.
Το νόημα είναι ότι η clone δημιουργεί ένα νέο αντικέιμενο και αλλάζει τα στοιχεία του παίρνοντας τα στοιχεία του αντικείμενου που θέλω να αντιγράψω και για τον λόγο αυτό έχω υλοποιήσει την dstr_clone
για την αποδέσμευση της μνήμης που δεσμεύεται και καταστρέφοντας το αντικείμενο καλώντας τους κατάλληλους constructors.Τέλος η clone_encrypt_and_print κάνει ακριβώς ότι ζητάει η
εκφώνηση απλά τονίζω ότι τους μεσαίους χαρακτήρες της συμβολοσειράς τους επιλέγει διαιρώντας το μήκος της με το 2 αν είναι περιττό το μήκος της(ένας μεσαίος χαρακτήρας) ενώ αν είναι άρτιο ακολουθώ
την ίδια διαδικασία και ταυτόχρονα προσθέτω το 1 για να πάρω και τους δύο μεσαίους χαρακτήρες.

