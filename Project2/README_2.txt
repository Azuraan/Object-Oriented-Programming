README:

Εντολή μεταγλώττισης: Έχοντας προσθέσει μέσα στο παραδοτέο ένα αρχείο Makefile, χρείαζεστε μόνο την εντολή make αλλιως απλα g++ -c κάθε αρχείο πηγαίου κώδικα και μετα
	g++ -o prog και όλα τα αντικειμενικά αρχεία.
Πληροφορίες και Αιτιολογήσεις σχετικά με τις σχεδιαστικές μου επιλογές: 
	Χρησιμοποιώ δυναμικά δευσμευμένο πίνακα δεικτών σε κλάσεις thread για το πλήθος των thread μέσα στο forum και σε κλασεις post για το πλήθος των post μέσα στο thread.
Και στις δύο περιπτώσεις ζητάω να δωθεί απο το πληκτρολόγιο ο αριθμός των thread ή των post αντίστοιχα για να ορίσω το size του πίνακα.Ο λόγος που χρησιμοποιώ πίνακα είναι
ότι αποτελεί μια απλή δομή που μου επιτρέπει στην συγκεκριμένη άσκηση να αποθηκεύσω εύκολα τα δεδομένα που θέλω αλλά και μου επιτρέπει να κάνω εύκολη αποδέσμευση μνήμης που έχω
δεσμεύσει στο heap.Αρχικοποιώ κάθε πίνακα δεσμεύοντας μνήμη για την αντιστοίχη κλάση που είναι στοιχείο του, ενώ παράλληλα καλόντας τον constructor με δεδόμενα που ζήτησα πάλι να
δωθούν σαν είσοδος απο το πληκτρολόγιο (απλα δεν παίρνω πάνω από μια λέξη για κάθε string μέλος των κλάσεων), αρχικοποιώ τα μέλη της κλάσης-στοιχείου του πίνακα.Προκειμένου να γνωρίζω το τέλος του πίνακα,
 πάντα διαθέτω μια επιπλέον θέση που δείχνει σε NULL και όχι σε κλάση ώστε να διαχειρίζομαι τον πίνακα όπου χρειάζεται χώρις να περνάω το μεγέθος του σαν εξτρα ορισμα.Τα texts τα παίρνω έτοιμα και τυχαία από ενα στατικό
πίνακα μέσα στο σώμα του constructor της κλάσης thread.Για την ημερομηνία έχω ορίσει μια κλάση με μέλη τρείς ακέραιους που αντιπροσωπεύουν μέρα,μήνα και έτος αντίστοιχα.
Έχω φτίαξει costructor,συνάρτηση εκτύπωσης και ένα mutator function για να αλλάζω την date (και να μην μπορει ο χρήστης να το κάνει άμεσα αυτό,αν και δεν έχει μεγάλη σημασία)
 κυρίως μέσα στο μπλοκ επανάληψης των thread και post constructors. Για την κλάση thread πέρα απο τις βασικές συναρτήσεις που χρείαζονται για τα ζητούμενα της πρώτης άσκησης,
όπως η print,η printTheme για την εκτύπωση θέματος των thread ενός forum,η cmpTitle για την σύγκριση τίτλων thread,η search που μου επιτρέπει την αναζήτηση στα posts του thread τα οποία είναι private,
οι οποίες λειτουργούν σαν  accessors στα private μέρη της κλάσης, έχω ορίσει  την "post* get_post_ptr(int);" ώστε να ανακτώ την διεύθυνση του post που θέλω να εισάγω στο BSTree της δεύτερης άσκησης,διαφορετικά 
δεν θα μπορούσα να την ανακτήσω διότι είναι private μέλος κάθε thread.Στην κλάση post έχω ορίσει την cmpId πάλι για να αποκτήσω πρόσβαση στο id του post το οποιο είναι private μέλος του,
καθώς και την inline get_creator για να πάρω το όνομα του δημιουργού του post και να το εκχωρίσω σε ένα κόμβο του BSTree της δεύτερης άσκησης.Συγκεκριμένα για την δεύτερη άσκηση,
έχω ορίσει την class Tree μαζί με τα μέλη της όπως υποδεικνύονται απο την εκφώνηση της άσκησης και τις συναρτήσεις που υλοποιούν τις ιδιότητες που ζητούνται.Επιπλέον,έχω ορίσει
την struct list_of_posts που είναι η λίστα με τα posts κάθε κόμβου.Την όρισα σαν struct διότι επιθυμώ να μεταβάλλω τα μέλη της ,που είναι κατα κύριο λόγο δείκτες σε δεδομένα
τα οποία δεν μπορώ να αλλάξω χωρίς συνάρτηση (post* lpost), σε συναρτήσης άλλης κλάσης (πχ void TreeInsert(post&);) και θεωρώ ότι είναι πιο απλό απο το να υλοποιησώ κιαλλες συναρτήσεις
που θα χρησιμοποιούσα μόνο σε ένα μπλοκ, το οποιο θεωρώ περιττό(εξάλλου τα δεδομένα του post ειναι private).Οι συναρτήσεις της κλάσης Tree είναι κυριώς αναδρομικές (printTree ,TreeInsert, TreeEnhance, TreePositionToInsert).
Τέλος πιστεύω είναι απαραίτητο να τονίσω ότι την συνάρτησης εισαγωγής κόμβων σε ένα δέντρο από ενα άλλο δεύτερο δέντρο την χώρισα σε δύο αναδρομικές.Η μια ειναι η TreeEnhance
που "παίρνει" στην ουσία τους κόμβους του δεύτερου δέντρου που θέλω να βάλω στο πρώτο, αφού πρώτα τους μετατρέψει σε φύλλα (t->apaidi = NULL;t->dpaidi = NULL;) και τους 
"στέλνει" ως ορίσματα στην TreePositionToInsert η οποία ψάχνει να βρεί την κατάλληλη θέση να προστεθούν αυτοί οι κόμβοι αναδρομικά και στο τέλος τους συνδέει στο δέντρο
(χωρις να γίνεται κάποια new αφού οι κόμβοι έχουν ήδη δημιουργηθεί και μπορούμε να μεταβάλλουμε τους δείκτες του πρώτου δέντρου ώστε να δείχνουν σε αυτούς).Στην περίπτωση 
που υπάρχει ήδη κόμβος με το όνομα ενός δημιουργού, απλά προσθέτω στην λίστα του την λίστα του κόμβου του δεύτερου δέντρου αλλά εδώ διαγράφω τον κόμβο του δεύτερου δέντρου
αφού έχω ήδη τον κόμβο που χρειάζομαι στο πρώτο δέντρο.Δεν υπάρχει περίπτωση να έχουμε δείκτη που δείχνει σε τυχαία πράγματα διότι η TreeEnhance κάνει τον δείκτη να δείχνει 
σε NULL όταν κληθεί για τον κόμβο γονέα του και μέχρι τότε δεν χρησιμοποιείται κάπου ο δείκτης.Αν ο κόμβος που διαγράφεται είναι η ρίζα τότε προφανώς δεν μας ενδιαφέρει
αφού έχουμε μεταφέρει τους κόμβους του δέντρου στο πρώτο δέντρο.